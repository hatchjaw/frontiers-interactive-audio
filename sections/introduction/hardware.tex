\subsection{Hardware Platforms}\label{subsec:hardware-platforms}

The notion of taking a distributed approach to DSP is reliant on the
identification of a suitable supporting hardware platform.
For an accessible, distributed audio application, the ideal computing platform
should be small and inexpensive, plus easily and rapidly programmable;
of course, it should also provide audio and networking hardware, and, ideally,
well-documented APIs for programming and interacting with this hardware.

Recent years have seen the emergence of a number of small, low-cost platforms
for embedded systems development, perhaps best known amongst these being the
\textit{Arduino} family of microcontroller development boards,\footnote{
    \url{https://arduino.cc/}
}
whose open-source Software Development Kit (SDK), software libraries, and
Integrated Development Environment (IDE) have greatly improved the
accessibility of development on embedded systems~\citep{michon_embedded_2020}.
Though support for audio is limited via Arduino devices, a number of
audio-specific systems, programmable with the Arduino SDK and IDE, and
operable with many Arduino-compatible add-ons (sensors, displays, etc.), have
been produced;
these include various \textit{ESP32} and \textit{STM32} models, and the
\textit{Daisy} and \textit{Teensy} microcontroller ranges.
These platforms benefit from the wealth of tools, documentation and support
associated with Arduino and the surrounding D.I.Y.\ and maker communities.
Also worthy of consideration are the \textit{Raspberry Pi} and \textit{Bela}
platforms.
Though these are \textit{Embedded Linux Systems} rather than microcontrollers,
they are small-footprint devices, suitable for embedded applications.
Bela in particular has been designed with a focus on audio development and
interaction via sensors; it can be programmed via an accessible, web-based IDE,
and the user need not interact with the underlying Linux operating system.
Raspberry Pi is less approachable for audio development, and tends to be
operated as more of a general-purpose small computer, though support for
treating the platform like a microcontroller \textemdash{} taking a
\textit{bare metal} approach \textemdash{} is offered via the \textit{Circle}
environment.\footnote{\url{https://github.com/rsta2/circle}}

The above systems are typically programmed in C++, with support for audio
development provided by libraries such as Daisy's \textit{DaisySP} and Teensy's
\textit{Teensy Audio Library}, which each provide audio APIs and a selection of
pre-made algorithms for audio synthesis and DSP.\
Bela, as an alternative to its C++ audio API, can be programmed with the
graphical programming language PureData, and Teensy, as a complement to its
Audio Library, offers a web-based \textit{Audio System Design Tool}, via which
the user may describe an audio system diagrammatically and export the result to
C++.

This profusion of approaches, and a variety of platform-specific APIs, can
render embedded audio development somewhat difficult to approach.
A concerted effort has been made, however, by the community behind the
\textit{Faust} programming language,\footnote{\url{https://faust.grame.fr/}} to
provide support for embedded platforms.
Faust is a functional paradigm, audio domain-specific language, that was created
to serve as a ``viable and efficient alternative to
C/C++''~\citep{orlarey_faust_2009} for the development of audio applications on
a variety of platforms.
In Faust, a user can write high level sound synthesis or DSP code and export the
result to C++ that meets the requirements of the audio API on a given target
platform.
This is achieved via a series of platform-specific ``architecture files'' and
Faust's \texttt{faust2[...]} tools,\footnote{
    \url{https://faustdoc.grame.fr/manual/tools/}
} which include
\texttt{faust2bela}, \texttt{faust2teensy}, etc.~\citep{michon_real_2019,
    michon_embedded_2020}.
Developers are thus able to focus on writing audio code, rather than being
concerned with the peculiarities of the device or system upon which they wish
to deploy their program;
further, Faust's support for a variety of embedded platforms facilitates testing
and rapid prototyping.

\begin{table}[t]
    \centering
    \begin{tabular}{ c c c r }
        Platform &
        Processor &
        Memory &
        Price \\

        \midrule

        Teensy 4.1\tablefootnote{\url{https://pjrc.com/store/teensy41.html}} &
        ARM Cortex-M7 \qty{600}{\MHz} &
        \qty{1}{\mega\byte} SDRAM &
        \texteuro{32} \\

        Daisy Seed\tablefootnote{\url{https://electro-smith.com/daisy/daisy}} &
        ARM Cortex-M7 \qty{480}{\MHz} &
        \qty{64}{\mega\byte} SDRAM &
        \texteuro{28} \\

        ESP32-LyraTD\tablefootnote{\url{https://espressif.com/en/products/devkits/esp-audio-devkits}} &
        Dual core Xtensa LX6 \qty{240}{\MHz} &
        \qty{8}{\mega\byte} PSRAM &
        \texteuro{19} \\

        STM32H747I\tablefootnote{\url{https://st.com/en/evaluation-tools/stm32h747i-disco.html}} &
        ARM Cortex-M7 \qty{480}{\MHz} + M4 \qty{240}{\MHz} &
        \qty{1}{\mega\byte} RAM &
        \texteuro{94} \\

        Bela\tablefootnote{\url{https://shop.bela.io/products/bela-starter-kit}} &
        ARM Cortex-A8 \qty{1}{\GHz}\tablefootnote{\url{https://beagleboard.org/black}} &
        \qty{512}{\mega\byte} SDRAM &
        \texteuro{190} \\

        Raspberry Pi 4\tablefootnote{\url{https://www.raspberrypi.com/products/raspberry-pi-4-model-b/}} &
        ARM Cortex-A72 \qty{1.8}{\GHz} &
        \qtyrange{1}{8}{\giga\byte} SDRAM &
        \texteuro{30-100}
    \end{tabular}
    \caption{Comparison of selected embedded audio development platforms.
    Prices as of January 2024.}
    \label{tab:embedded-comparison}
\end{table}

A comparison of selected devices can be found in
\tabref{tab:embedded-comparison}.
Bela is significantly more powerful than the microcontroller systems, but it is
commensurately costly.
The Raspberry Pi is also very capable, and a model with \qty{1}{\giga\byte} RAM
may cost as little as \texteuro{30};
its operating system stands as an impediment, however, to implementations that
seek to prioritise audio functionality above all.
Support for bare metal development on Raspberry Pi is not comprehensive, and
there is no Faust tool to produce code that is compatible with Circle.
Daisy Seed is well-appointed with memory (which is important for DSP algorithms
featuring long delay-lines, for example), but does not feature ethernet support.
Teensy 4.1, and the selected ESP32 and STM32 devices support networking via
ethernet add-ons, but the ESP32's CPU is underpowered, and the STM32 is
unfavourably-priced.
Though lacking in memory, Teensy's processor, low price, and networking support
make it an attractive candidate platform for a distributed, networked audio
implementation.
Further, thanks to the presence of a vibrant developer community, utilities such
as \textit{TyTools}\footnote{\url{https://koromix.dev/tytools}} exist, and can
be used to program multiple Teensy devices in a single command \textemdash{}
useful for a system distributed amongst many such devices.

One respect in which Teensy is found wanting is audio fidelity.
By default, its audio add-on (or \textit{shield}) produces CD quality output
(16-bit, \qty{44.1}{\kHz}), falling short of modern requirements for
high-quality audio, such as offered by Daisy Seed (24-bit, \qty{96}{\kHz}).
While Teensy's sampling rate can be increased, sample resolution is fixed by
the Teensy Audio Library and at the level of the audio codec.
In spite of this shortcoming, and in light of its other, more advantageous
qualities, Teensy was selected as the platform upon which to conduct
development.
